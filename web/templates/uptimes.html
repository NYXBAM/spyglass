<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Uptime Monitor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 100%);
      color: #ffffff;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 30px;
      padding: 20px 0;
      border-bottom: 2px solid rgba(0, 255, 153, 0.2);
    }
    
    .btn {
      padding: 12px 24px;
      background: linear-gradient(135deg, #00ff99 0%, #00cc7a 100%);
      border: none;
      border-radius: 12px;
      color: #000;
      font-weight: 600;
      text-decoration: none;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 255, 153, 0.3);
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 255, 153, 0.4);
    }
    
    h2 {
      color: #00ff99;
      font-size: 2.5rem;
      font-weight: 700;
      text-shadow: 0 0 20px rgba(0, 255, 153, 0.5);
    }
    
    .chart-container {
      background: rgba(30, 30, 46, 0.8);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(0, 255, 153, 0.1);
    }
    
    canvas {
      border-radius: 16px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: rgba(30, 30, 46, 0.6);
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      border: 1px solid rgba(0, 255, 153, 0.2);
      backdrop-filter: blur(5px);
    }
    
    .stat-value {
      font-size: 2rem;
      font-weight: 700;
      color: #00ff99;
      margin-bottom: 5px;
    }
    
    .stat-label {
      color: #a0a0a0;
      font-size: 0.9rem;
      margin-bottom: 10px;
    }

    .downtime-info {
      font-size: 0.8rem;
      color: #ff6b6b;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>ðŸ“ˆ Uptime Monitor</h2>
      <a href="/" class="btn">â¬… Back to Status</a>
    </div>
    
    <div class="stats-grid" id="statsGrid">
      <!-- Stats will be populated here -->
    </div>
    
    <div class="chart-container">
      <canvas id="uptimeChart" width="1000" height="400"></canvas>
    </div>
  </div>

  <script>
    fetch("/uptime-data", { cache: "no-store" })
      .then(res => {
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        return res.json();
      })
      .then(data => {
        console.log("Received data:", data);
        
        const grouped = {};
        data.forEach(entry => {
          if (!grouped[entry.target]) grouped[entry.target] = [];
          try {
              grouped[entry.target].push({
                  timestamp: new Date(entry.timestamp).getTime(),
                  status: entry.status === "up"
              });
          } catch (e) {
              console.error("Invalid date for entry:", entry, e);
          }
        });

        const datasets = [];
        const stats = [];
        

        const colors = [
          '#00ff99', '#ff6b6b', '#4ecdc4', '#45b7d1', 
          '#96ceb4', '#ffeaa7', '#dda0dd', '#98d8c8'
        ];
        let colorIndex = 0;
        
        for (const [target, logs] of Object.entries(grouped)) {
          console.log("Processing target:", target, "logs:", logs);
          
          logs.sort((a, b) => a.timestamp - b.timestamp);

          const chartData = [];
          const now = Date.now();
          const dayAgo = now - (24 * 60 * 60 * 1000);
          const recentLogs = logs.filter(log => log.timestamp >= dayAgo);
          
          if (recentLogs.length > 0) {
            recentLogs.forEach(log => {
              const timeLabel = new Date(log.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
              chartData.push({
                x: timeLabel,
                y: log.status ? 0.5 : -0.5,
                timestamp: log.timestamp
              });
            });
            
            const lastStatus = logs[logs.length - 1].status;
            chartData.push({
              x: new Date(now).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
              y: lastStatus ? 0.5 : -0.5
            });
          }
          
          let totalUpTime = 0;
          let totalTime = 0;
          let downtimeEvents = [];
          const currentTime = Date.now();
          const logsIn24h = logs.filter(log => log.timestamp >= dayAgo);
          
          if (logsIn24h.length === 0) {
            if (logs.length > 0) {
              const lastLog = logs[logs.length - 1];
              
              totalTime = 24 * 60 * 60 * 1000; // 24 hours in ms
              totalUpTime = lastLog.status ? totalTime : 0;
              
              if (!lastLog.status) {
                downtimeEvents.push({
                  start: dayAgo,
                  end: currentTime,
                  duration: totalTime
                });
              }
            }
          } else if (logsIn24h.length === 1) {
            const singleLog = logsIn24h[0];
            const timeFromLog = currentTime - singleLog.timestamp;
            totalTime = timeFromLog;
            totalUpTime = singleLog.status ? timeFromLog : 0;
            
            if (!singleLog.status) {
              downtimeEvents.push({
                start: singleLog.timestamp,
                end: currentTime,
                duration: timeFromLog
              });
            }
          } else {
            for (let i = 0; i < logsIn24h.length - 1; i++) {
              const currentLog = logsIn24h[i];
              const nextLog = logsIn24h[i + 1];
              const duration = nextLog.timestamp - currentLog.timestamp;
              
              totalTime += duration;
              if (currentLog.status) {
                totalUpTime += duration;
              } else {
                downtimeEvents.push({
                  start: currentLog.timestamp,
                  end: nextLog.timestamp,
                  duration: duration
                });
              }
            }
            
            const lastLog = logsIn24h[logsIn24h.length - 1];
            const lastDuration = currentTime - lastLog.timestamp;
            totalTime += lastDuration;
            if (lastLog.status) {
              totalUpTime += lastDuration;
            } else {
              downtimeEvents.push({
                start: lastLog.timestamp,
                end: currentTime,
                duration: lastDuration
              });
            }
          }
          
          const uptimeRatio = totalTime > 0 ? Math.min(totalUpTime / totalTime, 1.0) : 0;
          const uptimePercent = (uptimeRatio * 100).toFixed(1);
          
          const color = colors[colorIndex % colors.length];
          colorIndex++;

          datasets.push({
            label: `${target} (${uptimePercent}%)`,
            data: chartData,
            borderColor: color,
            backgroundColor: color + '15',
            fill: false,
            tension: 0,
            borderWidth: 3,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: color,
            pointBorderColor: '#ffffff',
            pointBorderWidth: 2,
            pointHoverBackgroundColor: color,
            pointHoverBorderColor: '#ffffff',
            pointHoverBorderWidth: 2,
            spanGaps: false,
            stepped: 'after'
          });
          
          
          let downtimeInfo = '';
          if (downtimeEvents.length > 0) {
            const totalDowntime = downtimeEvents.reduce((sum, event) => sum + event.duration, 0);
            const downtimeMinutes = Math.floor(totalDowntime / (1000 * 60));
            const lastDowntime = downtimeEvents[downtimeEvents.length - 1];
            const lastDowntimeStr = new Date(lastDowntime.start).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            
            downtimeInfo = `${downtimeEvents.length} outages, ${downtimeMinutes}min total. Last: ${lastDowntimeStr}`;
          } else {
            downtimeInfo = 'No outages';
          }
          
          stats.push({
            target: target,
            uptime: uptimePercent,
            color: color,
            downtimeInfo: downtimeInfo
          });
        }
        
        const statsGrid = document.getElementById('statsGrid');
        statsGrid.innerHTML = stats.map(stat => `
          <div class="stat-card">
            <div class="stat-value" style="color: ${stat.color}">${stat.uptime}%</div>
            <div class="stat-label">${stat.target}</div>
            <div class="downtime-info">${stat.downtimeInfo}</div>
          </div>
        `).join('');

        const allTimes = new Set();
        datasets.forEach(dataset => {
          dataset.data.forEach(point => allTimes.add(point.x));
        });
        const sortedTimes = Array.from(allTimes).sort((a, b) => {
          const timeA = a.split(':').map(Number);
          const timeB = b.split(':').map(Number);
          return timeA[0] * 60 + timeA[1] - (timeB[0] * 60 + timeB[1]);
        });

        new Chart(document.getElementById("uptimeChart"), {
          type: "line",
          data: {
            labels: sortedTimes,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              intersect: false,
              mode: 'index'
            },
            plugins: {
              legend: {
                labels: {
                  color: '#ffffff',
                  font: {
                    size: 14,
                    weight: '600'
                  },
                  usePointStyle: true,
                  pointStyle: 'circle'
                },
                position: 'top'
              },
              tooltip: {
                backgroundColor: 'rgba(30, 30, 46, 0.95)',
                titleColor: '#00ff99',
                bodyColor: '#ffffff',
                borderColor: '#00ff99',
                borderWidth: 1,
                cornerRadius: 12,
                displayColors: true,
                callbacks: {
                  label: ctx => {
                    const serviceName = ctx.dataset.label.split(' (')[0];
                    const status = ctx.parsed.y === 0.5 ? "ðŸŸ¢ ONLINE" : "ðŸ”´ OFFLINE";
                    const uptime = ctx.dataset.label.match(/\((.+)%\)/)?.[1] || '0';
                    return `${serviceName}: ${status} (${uptime}% uptime)`;
                  },
                  afterLabel: ctx => {
                    if (ctx.raw.timestamp) {
                      return `Status changed: ${new Date(ctx.raw.timestamp).toLocaleString()}`;
                    }
                    return '';
                  }
                }
              }
            },
            scales: {
              y: {
                ticks: {
                  callback: val => val === 0.5 ? "ðŸŸ¢ ONLINE" : val === -0.5 ? "ðŸ”´ OFFLINE" : "",
                  color: '#ffffff',
                  font: { 
                    weight: '600',
                    size: 12
                  },
                  padding: 10
                },
                grid: {
                  color: 'rgba(255, 255, 255, 0.1)',
                  drawBorder: false
                },
                border: {
                  display: false
                },
                min: -1,
                max: 1
              },
              x: {
                ticks: {
                  color: '#ffffff',
                  font: { 
                    weight: '500',
                    size: 11
                  },
                  maxTicksLimit: 15
                },
                grid: {
                  color: 'rgba(255, 255, 255, 0.05)',
                  drawBorder: false
                },
                border: {
                  display: false
                }
              }
            }
          }
        });
      })
      .catch(error => console.error("Fetch error:", error));
  </script>
</body>
</html>