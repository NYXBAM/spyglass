<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Uptime Monitor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background-color: #121212;
      color: #fff;
      padding: 20px;
    }
    canvas {
      background-color: #1e1e1e;
      border-radius: 8px;
      padding: 10px;
    }
    h2 {
      color: #00ff99;
    }
    .btn {
      padding: 8px 16px;
      background: #00ff99;
      border: none;
      border-radius: 5px;
      color: #000;
      font-weight: bold;
      text-decoration: none;
      margin-bottom: 20px;
      display: inline-block;
    }
  </style>
</head>
<body>
  <a href="/" class="btn">‚¨Ö Back to Status</a>
  <h2>üìà Uptime Monitor </h2>
  <canvas id="uptimeChart" width="1000" height="400"></canvas>

  <script>
    fetch("/uptime-data", { cache: "no-store" })
      .then(res => res.json())
      .then(data => {
        const intervalMinutes = 5; 
        const hoursToShow = 24;
    
        const now = new Date();
        const startTime = new Date(now.getTime() - hoursToShow * 60 * 60 * 1000);
        const timeLabels = [];
        for (let t = startTime.getTime(); t <= now.getTime(); t += intervalMinutes * 60 * 1000) {
            timeLabels.push(new Date(t).toISOString().slice(0, -5)); // –ë–µ—Ä–µ–º–æ –ª–∏—à–µ –¥–æ —Å–µ–∫—É–Ω–¥, –±–µ–∑ "Z" –¥–ª—è —Å–ø—Ä–æ—â–µ–Ω–Ω—è
        }
    
        const grouped = {};
        data.forEach(entry => {
          if (!grouped[entry.target]) grouped[entry.target] = [];
          grouped[entry.target].push({
              time: new Date(entry.timestamp).toISOString().slice(0, -5), // –°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è —Ñ–æ—Ä–º–∞—Ç—É
              status: entry.status === "up" ? 0.5 : -0.5
          });
        });
    
        const datasets = [];
        for (const [target, logs] of Object.entries(grouped)) {
          const dataPoints = [];
          let lastStatus = 0;
          let logIndex = 0;
        
          for (const labelTime of timeLabels) {
            while (logIndex < logs.length && new Date(logs[logIndex].time).getTime() <= new Date(labelTime).getTime()) {
                lastStatus = logs[logIndex].status;
                logIndex++;
            }
            dataPoints.push(lastStatus);
          }
      
          const upCount = dataPoints.filter(v => v === 0.5).length;
          const uptimePercent = dataPoints.length > 0 ? ((upCount / dataPoints.length) * 100).toFixed(1) : 0;
      
          datasets.push({
            label: `${target} (${uptimePercent}%)`,
            data: dataPoints,
            borderColor: `hsl(${Math.floor(Math.random() * 360)}, 70%, 50%)`,
            backgroundColor: `hsl(${Math.floor(Math.random() * 360)}, 70%, 50%, 0.2)`,
            fill: false,
            tension: 0.4, 
            borderWidth: 2,
            pointRadius: 0,
            pointHoverRadius: 0
          });
        }
    
        const labels = timeLabels.map(d => d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}));
    
        new Chart(document.getElementById("uptimeChart"), {
          type: "line",
          data: {
            labels: labels,
            datasets: datasets
          },
          options: {
            responsive: true,
            scales: {
              y: {
                ticks: {
                  callback: val => val === 0.5 ? "UP" : val === -0.5 ? "DOWN" : "",
                  color: '#00ff99',
                  font: { weight: 'bold' }
                },
                grid: {
                  color: '#333'
                },
                min: -1,
                max: 1
              },
              x: {
                ticks: {
                  color: '#00ff99',
                  font: { weight: 'bold' }
                },
                grid: {
                  color: '#222'
                }
              }
            },
            plugins: {
              legend: {
                labels: {
                  color: '#00ff99',
                  font: {
                    size: 14,
                    weight: 'bold'
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y === 0.5 ? "UP" : "DOWN"}`
                }
              }
            }
          }
        });
      });
  </script>
</body>
</html>