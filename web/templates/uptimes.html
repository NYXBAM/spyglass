<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Uptime Monitor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 100%);
      color: #ffffff;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 30px;
      padding: 20px 0;
      border-bottom: 2px solid rgba(0, 255, 153, 0.2);
    }
    
    .btn {
      padding: 12px 24px;
      background: linear-gradient(135deg, #00ff99 0%, #00cc7a 100%);
      border: none;
      border-radius: 12px;
      color: #000;
      font-weight: 600;
      text-decoration: none;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 255, 153, 0.3);
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 255, 153, 0.4);
    }
    
    h2 {
      color: #00ff99;
      font-size: 2.5rem;
      font-weight: 700;
      text-shadow: 0 0 20px rgba(0, 255, 153, 0.5);
    }
    
    .chart-container {
      background: rgba(30, 30, 46, 0.8);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(0, 255, 153, 0.1);
    }
    
    canvas {
      border-radius: 16px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: rgba(30, 30, 46, 0.6);
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      border: 1px solid rgba(0, 255, 153, 0.2);
      backdrop-filter: blur(5px);
    }
    
    .stat-value {
      font-size: 2rem;
      font-weight: 700;
      color: #00ff99;
      margin-bottom: 5px;
    }
    
    .stat-label {
      color: #a0a0a0;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>üìà Uptime Monitor</h2>
      <a href="/" class="btn">‚¨Ö Back to Status</a>
    </div>
    
    <div class="stats-grid" id="statsGrid">
      <!-- Stats will be populated here -->
    </div>
    
    <div class="chart-container">
      <canvas id="uptimeChart" width="1000" height="400"></canvas>
    </div>
  </div>

  <script>
    fetch("/uptime-data", { cache: "no-store" })
      .then(res => {
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        return res.json();
      })
      .then(data => {
        console.log("Received data:", data); 
        const intervalMinutes = 5; 
        const hoursToShow = 24;
    
        const timestamps = data.map(entry => new Date(entry.timestamp).getTime());
        const minTime = Math.min(...timestamps) - hoursToShow * 60 * 60 * 1000;
        const maxTime = Math.max(...timestamps);
        const timeLabels = [];
        for (let t = minTime; t <= maxTime; t += intervalMinutes * 60 * 1000) {
            timeLabels.push(new Date(t).toISOString().slice(0, 19));
        }
    
        const grouped = {};
        data.forEach(entry => {
          if (!grouped[entry.target]) grouped[entry.target] = [];
          try {
              const time = new Date(entry.timestamp).toISOString().slice(0, 19);
              grouped[entry.target].push({
                  time: time,
                  timestamp: new Date(entry.timestamp).getTime(),
                  status: entry.status === "up"
              });
          } catch (e) {
              console.error("Invalid date for entry:", entry, e);
          }
        });
    
        const datasets = [];
        const stats = [];
        
        // Generate colors for each target
        const colors = [
          '#00ff99', '#ff6b6b', '#4ecdc4', '#45b7d1', 
          '#96ceb4', '#ffeaa7', '#dda0dd', '#98d8c8'
        ];
        let colorIndex = 0;
        
        for (const [target, logs] of Object.entries(grouped)) {
          console.log("Processing target:", target, "logs:", logs);
          
          // Sort logs by timestamp
          logs.sort((a, b) => a.timestamp - b.timestamp);
          
          const dataPoints = [];
          
          for (const labelTime of timeLabels) {
              const labelTimeMs = new Date(labelTime).getTime();
              
              // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–∞–π–±–ª–∏–∂—á–∏–π –∑–∞–ø–∏—Å –î–û —Ü—å–æ–≥–æ —á–∞—Å—É
              let lastRelevantLog = null;
              for (let i = logs.length - 1; i >= 0; i--) {
                  if (logs[i].timestamp <= labelTimeMs) {
                      lastRelevantLog = logs[i];
                      break;
                  }
              }
              
              // –Ø–∫—â–æ —î –∑–∞–ø–∏—Å - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –π–æ–≥–æ —Å—Ç–∞—Ç—É—Å, —ñ–Ω–∞–∫—à–µ null (–Ω–µ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—î–º–æ)
              if (lastRelevantLog) {
                  dataPoints.push(lastRelevantLog.status ? 0.5 : -0.5);
              } else {
                  dataPoints.push(null); // null –æ–∑–Ω–∞—á–∞—î —â–æ –Ω–µ–º–∞—î –¥–∞–Ω–∏—Ö –¥–ª—è —Ü—å–æ–≥–æ —á–∞—Å—É
              }
          }
          
          // –ü–†–ê–í–ò–õ–¨–ù–ò–ô –†–û–ó–†–ê–•–£–ù–û–ö –ê–ü–¢–ê–ô–ú–£ - —Ä–∞—Ö—É—î–º–æ —á–∞—Å, –∞ –Ω–µ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ç–æ—á–æ–∫
          let totalUpTime = 0;
          let totalTime = 0;
          
          if (logs.length > 0) {
            // –°–æ—Ä—Ç—É—î–º–æ –ª–æ–≥–∏ –∑–∞ —á–∞—Å–æ–º
            const sortedLogs = [...logs].sort((a, b) => a.timestamp - b.timestamp);
            
            // –†–∞—Ö—É—î–º–æ —á–∞—Å –º—ñ–∂ –∑–∞–ø–∏—Å–∞–º–∏
            for (let i = 0; i < sortedLogs.length - 1; i++) {
              const currentLog = sortedLogs[i];
              const nextLog = sortedLogs[i + 1];
              const duration = nextLog.timestamp - currentLog.timestamp;
              
              totalTime += duration;
              if (currentLog.status) {
                totalUpTime += duration;
              }
            }
            
            // –î–æ–¥–∞—î–º–æ —á–∞—Å –≤—ñ–¥ –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –∑–∞–ø–∏—Å—É –¥–æ –ø–æ—Ç–æ—á–Ω–æ–≥–æ –º–æ–º–µ–Ω—Ç—É
            const lastLog = sortedLogs[sortedLogs.length - 1];
            const currentTime = Date.now();
            const durationFromLast = currentTime - lastLog.timestamp;
            
            totalTime += durationFromLast;
            if (lastLog.status) {
              totalUpTime += durationFromLast;
            }
            
            // –Ø–∫—â–æ totalTime –≤—Å–µ —â–µ 0 (—Ç—ñ–ª—å–∫–∏ –æ–¥–∏–Ω –∑–∞–ø–∏—Å), –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π –ø–µ—Ä—ñ–æ–¥
            if (totalTime === 0) {
              totalTime = durationFromLast > 0 ? durationFromLast : 1; // –º—ñ–Ω—ñ–º—É–º 1–º—Å —â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ –¥—ñ–ª–µ–Ω–Ω—è –Ω–∞ 0
              if (lastLog.status) {
                totalUpTime = totalTime;
              }
            }
          }
          
          const uptimePercent = totalTime > 0 ? ((totalUpTime / totalTime) * 100).toFixed(1) : 0;
          
          const color = colors[colorIndex % colors.length];
          colorIndex++;
      
          datasets.push({
            label: `${target} (${uptimePercent}%)`,
            data: dataPoints,
            borderColor: color,
            backgroundColor: color + '15',
            fill: false,
            tension: 0, 
            borderWidth: 2,
            pointRadius: 2,
            pointHoverRadius: 5,
            pointBackgroundColor: color,
            pointBorderColor: '#ffffff',
            pointBorderWidth: 1,
            pointHoverBackgroundColor: color,
            pointHoverBorderColor: '#ffffff',
            pointHoverBorderWidth: 2,
            spanGaps: false,
            stepped: 'middle' // –°—Ç—É–ø—ñ–Ω—á–∞—Å—Ç–∏–π –∞–ª–µ –∑ —Å–µ—Ä–µ–¥–∏–Ω–∏
          });
          
          stats.push({
            target: target,
            uptime: uptimePercent,
            color: color
          });
        }
        
        // Populate stats grid
        const statsGrid = document.getElementById('statsGrid');
        statsGrid.innerHTML = stats.map(stat => `
          <div class="stat-card">
            <div class="stat-value" style="color: ${stat.color}">${stat.uptime}%</div>
            <div class="stat-label">${stat.target}</div>
          </div>
        `).join('');
    
        const labels = timeLabels.map(d => new Date(d).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}));
    
        new Chart(document.getElementById("uptimeChart"), {
          type: "line",
          data: {
            labels: labels,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              intersect: false,
              mode: 'index'
            },
            plugins: {
              legend: {
                labels: {
                  color: '#ffffff',
                  font: {
                    size: 14,
                    weight: '600'
                  },
                  usePointStyle: true,
                  pointStyle: 'circle'
                },
                position: 'top'
              },
              tooltip: {
                backgroundColor: 'rgba(30, 30, 46, 0.95)',
                titleColor: '#00ff99',
                bodyColor: '#ffffff',
                borderColor: '#00ff99',
                borderWidth: 1,
                cornerRadius: 12,
                displayColors: true,
                callbacks: {
                  label: ctx => {
                    const serviceName = ctx.dataset.label.split(' (')[0];
                    const status = ctx.parsed.y === 0.5 ? "üü¢ ONLINE" : "üî¥ OFFLINE";
                    const uptime = ctx.dataset.label.match(/\((.+)%\)/)?.[1] || '0';
                    return `${serviceName}: ${status} (${uptime}% uptime)`;
                  }
                }
              }
            },
            scales: {
              y: {
                ticks: {
                  callback: val => {
                    if (val === 0.5) return "üü¢ ONLINE";
                    if (val === -0.5) return "üî¥ OFFLINE";
                    return "";
                  },
                  color: '#ffffff',
                  font: { 
                    weight: '600',
                    size: 12
                  },
                  padding: 10
                },
                grid: {
                  color: 'rgba(255, 255, 255, 0.1)',
                  drawBorder: false
                },
                border: {
                  display: false
                },
                min: -1,
                max: 1
              },
              x: {
                ticks: {
                  color: '#ffffff',
                  font: { 
                    weight: '500',
                    size: 11
                  },
                  maxTicksLimit: 12
                },
                grid: {
                  color: 'rgba(255, 255, 255, 0.05)',
                  drawBorder: false
                },
                border: {
                  display: false
                }
              }
            }
          }
        });
      })
      .catch(error => console.error("Fetch error:", error));
  </script>
</body>
</html>